# Rama Simulator, Copyright (C) 2014-2020 Russell Smith.
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
# more details.

# @@@ TODO: Notes for things to add to this document
# * Tutorial.
#   - ALMA coupler. Model. S parameters. Sweeps. Optimize. Build in reality
#   - Wifi house. Radiation boundary.
# * Add x,y,z axis to waveguide mode picture.
# * Command line arguments.
# * The mathematical backbone of Rama is described in this companion document,
#   @link{https://evenedric.github.io/fem.html}{The Finite Element Method}.
# * Make it clear that optimize() should return many values and that they can
#   be negative. Don't return values like a^2+b^2+c^2, return a,b,c instead.
# * Spell check.

@title{Rama}
@subtitle{v@arg{version}}

@figure{images/horn_phase.gif}{}

@contents{}

#############################################################################
@section{Introduction to Rama}

Rama is an open source physics simulator for electromagnetic and quantum
mechanical systems. It is intended for physics education, and to be an
engineering design tool. It simulates two dimensional systems, though it will
also simulate some 3D systems that have the right kind of symmetry. Rama is
based on the finite element method. Compared to other such simulators, Rama has
some unique features:

@list{
@* Rama is fast. Solutions to many interesting problems are produced in a
   fraction of a second.
@* Because Rama is fast, it is interactive. You can adjust your model with
   sliders and see the solution change in real time. This is a good way to
   develop quick intuitions about many physical situations.
@* Rama models are created with scripts, rather than with CAD tools. This may
   seem like a disadvantage, but models created this way can be more easily
   parameterized and made interactive.
@* Rama's built in optimization tools quickly solve for optimal configurations.
@* Rama has many ways to visualize solutions, and can generate all kinds of
   plots to help you understand your model.
}

The 2D limitation might seem to rule out using Rama for serious design
problems. However there are many 3D problems with symmetries that allow Rama to
generate exact solutions, especially problems involving
@link{http://en.wikipedia.org/wiki/Waveguide}{waveguide}-fed cavities. Some
other problems have 2D models that approximate the full 3D situations, and
Rama can provide design intuition in these cases, although not exact solutions.
Rama can often be the starting point for a new design, to get the basics worked
out quickly before moving to another simulator's much slower 3D design process.

@subsection{Getting Rama}

Here are the @link{http://ramasimulator.org/setup_rama.exe}{Windows installer}
and the @link{http://ramasimulator.org/Rama.dmg}{Mac image}
for the latest stable version of Rama.
All Rama development is done on @link{https://github.com/Evenedric/stuff}{github}.

@subsection{Rama Examples}

Here is an example of interactively changing the width of a horn antenna, to
investigate the point at which it starts radiating:

@figure{images/horn_sweep.gif}{}

Here we simulate a WR-10 coupler designed for the ALMA radio telescope, to
check its performance:

@figure{images/example_alma.jpg}{}

Here we inspect the electric field in a mode of a waveguide:

@figure{images/example_mode.jpg}{}

Here we simulate a quantum mechanical wave packet being deflected by the
potential radiating from a point charge.

@figure{images/example_qm.jpg}{}

#############################################################################
@section{What can be simulated}

@subsection{Electromagnetic cavities (Z field)}

Rama can solve
@link{http://en.wikipedia.org/wiki/Maxwell%27s_equations}{Maxwell's equations}
to determine the electromagnetic fields in @b{@c{Ez}} cavities, which are
bounded by walls of constant depth in the Z direction, and where all electric
fields point in the Z direction:

@figure{images/cavity_Ez.png}{}

The cavity depth is arbitrary, in fact the solution is independent of the
depth. A depth of infinity models free space propagation.

The interior of the cavity can be free space or can contain materials with
various dielectric properties. The boundary of the cavity can be metal walls,
ports (from which energy enters or leaves) or absorbers used in radiation
problems.
The ports are actually
@link{http://en.wikipedia.org/wiki/Waveguide}{rectangular waveguides}. It is
assumed that the fields at the ports have the @m{TE_{10}} mode. Energy is
injected through excited ports and exits through all ports and absorbers.

These cavities can be models of real life structures make from sheet metal, or
milled out of metal blocks using "split block construction" like so:

@figure{images/splitblock.jpg}{(image from @link{https://www.techbriefs.com/component/content/article/tb/techbriefs/physical-sciences/14855}{here})}

Under the hood, rama computes a 2D field @m{\phi(x,y)} such that the full 3D
electric and magnetic phasor fields are

@M{
  \mathbf{E} &= \left[ 0, 0, \phi(x,y) \right] \\
  \mathbf{H} &= {i \by \mu \omega} \: \left[
   {\del \phi(x,y) \by \del y}, -{\del \phi(x,y) \by \del x}, 0 \right]
}

where @m{\phi} satisfies the 2D
@link{https://en.wikipedia.org/wiki/Helmholtz_equation}{Helmholtz equation}
with wave number @m{k = \omega \sqrt{\mu \epsilon}}.


@subsection{Electromagnetic cavities (XY field)}

Rama can solve
@link{http://en.wikipedia.org/wiki/Maxwell%27s_equations}{Maxwell's equations}
to determine the electromagnetic fields in @b{@c{Exy}} cavities, which are
bounded by walls of constant depth in the Z direction, and where all electric
fields are in the XY plane:

@figure{images/cavity_Exy.png}{}

The cavity depth is arbitrary. The solution depends on depth, and if the depth
is too small the cavity will not support propagating waves.
A depth of infinity models free space propagation.

As with @b{@c{Ez}} cavities, the interior can be free space or can contain
dielectrics, and the boundary can be metal, @m{TE_{10}} ports, or absorbers.

Under the hood, rama computes a 2D field @m{\phi(x,y)} such that the full 3D
electric and magnetic phasor fields are

@M{
  \mathbf{E} &= \alpha {i d \mu \omega \by \pi}
                \: \cos\left({\pi z \by d}\right) \: \left[
   {\del \phi(x,y) \by \del y}, -{\del \phi(x,y) \by \del x}, 0 \right] \\
  \mathbf{H} &= \left[ \alpha \: \sin\left({\pi z \by d}\right) {\del \phi(x,y) \by \del x},
                       \alpha \: \sin\left({\pi z \by d}\right) {\del \phi(x,y) \by \del y},
                       \cos\left({\pi z \by d}\right) \phi(x,y) \right] \\
   \alpha &= { \pi d \by \pi^2-d^2 k_0^2}
}

where @m{d} is the depth of the cavity and @m{\phi} satisfies the 2D
@link{https://en.wikipedia.org/wiki/Helmholtz_equation}{Helmholtz equation}
with wave number @m{k = \sqrt{\omega^2 \mu \epsilon - \pi^2/d^2}}.


@subsection{Waveguide modes}

Rama can solve
@link{http://en.wikipedia.org/wiki/Maxwell%27s_equations}{Maxwell's equations}
to determine the electromagnetic fields in waveguides of constant cross section:

@figure{images/waveguide.png}{}

The @b{@c{TE}} and @b{@c{TM}} modes can be separately computed.


@subsection{Schrödinger's equation}

Rama can solve the Schrödinger's equation for nonrelativistic particles in
a 2D cavity. The constant frequency (i.e. fixed momentum) Schrödinger equation
is solved:

@M{
  \nabla^2 \psi + {2 m \by \hbar} \left( \omega - {V \by \hbar} \right) \psi &= 0
}

We use Planck units with @m{\hbar=1} and @m{m=1/2}, giving

@M{
  \nabla^2 \psi + ( \omega - V ) \: \psi &= 0
}

The wave function @m{\psi} is computed within the cavity.
The interior of the cavity can be free space (@m{V=0}) or can contain areas
with nonzero @m{V} (in much the same way that electromagnetic cavities can
contain dielectric materials).

The boundary of the cavity can be walls where @m{\psi=0}, ports (from which
waves enter or leave) or absorbers used in radiation problems.
The ports behave similarly to those in @b{@c{Ez}} cavities.

#############################################################################
@section{Rama user interface}

@subsection{Windows and tabs}

Rama simulations are managed from a single window:

@figure{images/rama_ui.png}{}

The left hand pane contains the parameters defined by the model, which can be
adjusted by entering numerical values or by moving sliders.

The right hand pane contains various tabs that show different aspects of the
model. The window under each of these tabs can be dragged away to a separate
window - in this way it is possible to see several of those windows at once.

The "model" tab shows the geometry of the model, the mesh, and the field
solution. Mouse buttons are used to change the view:
@list{
@* Right click + drag: pan the view.
@* Mouse wheel: zoom in or out, centered around the mouse pointer.
@* Ctrl + right click + drag: zoom around the mouse pointer.
@* On Mac trackpads:
   @list{
     @* Pinch+zoom: zoom around the mouse pointer.
     @* Two finger swipes: pan the view.
   }
}

The "Sweep" tab is a plot that shows various values computed as a parameter
varies. It is often used to show S-parameters of model ports, but can also
plot any user value generated by the script.

The "S Params" tab is a plot that shows S parameters over frequency, for
multi-frequency solves.

The "Antenna" tab is a plot that shows the radiation emitted by the model for
each angle. It is only useful for certain models that have radiation boundaries
defined.

The "Script messages" tab shows errors and other output from the model.
When there is a model error the view will automatically switch to this tab.


@subsection{The model}

Model scripts are loaded with the File/Open menu command, or are specified on
the command line. Scripts are executed to create the model. If the "Field"
checkbox is ticked, the field solution is then computed and displayed. The
script is re-executed (and the field recomputed) when either:
@list{
@* A parameter is changed through its text box or slider.
@* The script is edited and saved with an external text editor.
@* The File/Reload menu command is selected.
}

The multi-choice box that defaults to "Hide mesh" can be used to show the mesh,
or to draw the dielectric properties into the model.

If the checkbox "Field" is ticked then the field solution is computed and
displayed. If it is not ticked then the model geometry (or mesh) is shown.

If the checkbox "Animate" is ticked, then the field solution is computed and
animated, so you can get a sense of how the waves flow.

The multi-choice box that defaults to "amplitude and phase" is used to select
how the field solution is displayed. The options (which depend on the cavity
type) are:
@list{
@* @b{Ez/Hz amplitude and phase}. Display the field solution directly, as the
   amplitude and phase of the electric or magnetic Z component (or in other
   words, the real part of the phasor @m{\phi}).
@* @b{Ez/Hz max amplitude}. Display the maximum amplitude of the field
   solution that is ever reached during animation (or in other words, the
   amplitude of the phasor).
@* @b{[Ex,Ey] max amplitude}. In @b{@c{Exy}} cavities display the maximum
   amplitude of the (Ex,Ey) vector.
@* @b{H & Jsurf amplitude}. In @b{@c{Ez}} cavities display the maximum
   amplitude of the (Hx,Hy) vector, which is also proportional to the amplitude
   of the surface current on the constant-Z walls.
@* @b{Rotated vector E}. In @b{@c{Exy}} cavities display the (Ex,Ey) vector,
   rotated by 90 degrees.
@* @b{Vector Jsurf}. In @b{@c{Ez}} cavities display the surface current
   vector at the constant-Z walls
@* @b{Vector E, Jsurf}. In @b{@c{Exy}} cavities display the (Ex,Ey) vector,
   which is also proportional to the surface current on the constant-Z walls.
@* @b{Vector H}. In @b{@c{Ez}} cavities display the (Hx,Hy) vector.
@* @b{Poynting vector}. Display the Poynting power flow vector.
}

During animation the phase of the displayed solution is rotated. If a
maximum amplitude is being displayed then the animation shows the amplitude of
the rotating phasor.

For waveguide mode display the following options are available:
@list{
@* @b{Ez} or @b{Hz} to view the Z component of the field.
@* @b{Ez amplitude} or @b{Hz amplitude} to view the absolute value of the Z
   component of the field.
@* @b{[Ex,Ey] amplitude} or @b{[Hx,Hy] amplitude} to view the amplitude of the
   X,Y component of the field.
@* @b{[Ex,Ey]} to view the (Ex,Ey) vector.
@* @b{[Hx,Hy]} to view the (Hx,Hy) vector.
}


@subsection{Menu command reference}

# We omit "system" menu commands that look differently on mac/windows/linux.
# For example on macs the "help/about" command appears under a separate menu
# for the application. The quit/exit commands is also system dependent.
# We also don't list keyboard shortcuts here because they're system dependent
# and easy to discover.

@list{
@* @b{File}
   @list{
   @* @b{Open model}: Open a new model script Lua file and executed it to
      create a new model.
   @* @b{Reload model}: Reload the current model script file, and execute it
      to recreate the model.
   @* @b{Auto-run model on change}: Automatically detect when the model script
      file changes, and reload it when that happens. This is on by default.
      This makes it convenient to develop models - just save it in your text
      editor and immediately see the results.
   @* @b{Export boundary as DXF}. Export the model boundary shape
      (@c{config.cd}) as a DXF file, so it can be imported into a CAD program.
   @* @b{Export boundary as x,y list} Export the model boundary shape
      (@c{config.cd}) as text file list of coordinates.
   @* @b{Export field as matlab data}. Save the mesh and current field
      solution to a matlab file. The following matrices are saved:
      @list{
      @* @c{p}: Mesh point coordinates.
      @* @c{t}: Mesh triangles, indexes into @c{p}.
      @* @c{u}: Solution complex values, one for each point.
      }
      In matlab the solution can be visualized with:
@===[
  patch('Vertices',p,'Faces',t,'FaceVertexCData',real(u),...
        'FaceColor','interp','EdgeColor','none'); axis equal
]===@
   @* @b{Export plot as matlab data}. Export the current sweep plot as a matlab
      file containing an @c{x} coordinate vector and a complex @c{y} matrix
      with columns for each port or channel. In matlab, to reproduce the sweep
      plot in dB use:
@===[
  plot(x,20*log10(abs(y)))
]===@
   @* @b{Export antenna pattern as matlab data}. Compute and export the
      antenna pattern. The following vectors are saved:
      @list{
      @* @c{azimuth} - the azimuths at which the far field is evaluated (radians).
      @* @c{field} - the complex values of the far field at each azimuth.
      @* @c{xcorrection}, @c{ycorrection} - used for phase center correction, as below.
      }
      To plot the beam pattern magnitude in dB:
@===[
  plot(azimuth,20*log10(abs(field)))
]===@
      To plot the beam phase, assuming a phase center at cx,cy (in config units):
@===[
  plot(azimuth,angle(field.*(xcorrection.^cx.*ycorrection.^cy)))
]===@
   }
@* @b{Edit}
   @list{
   @* @b{Copy parameters to clipboard}. Set the clipboard to a fragment of Lua
      code that sets the @c{default_parameters} table to the current
      parameter values. This can be pasted in to the Lua script, as a way of
      saving the current parameter values.
   }
@* @b{View}
   @list{
   @* @b{Zoom to extents}. Set the view so the entire model is visible.
   @* @b{Zoom in/out}. Zoom in to or out from the model, around the current
      mouse pointer position, in case other methods of zooming (like the mouse
      scroll wheel) are not available.
   @* @b{Set animation time to 0}. The animation time controls the phase of
      the wave or the position of the wideband pulse. This resets the time to
      zero, starting the animation from the beginning.
   @* @b{Increase/Decrease animation time}. Move the current animation time
      forwards or backwards by one unit.
   @* @b{Show boundary}: Select which features of the boundary are displayed:
      lines, ports, or vertices. Vertex derivatives with respect to the first
      checked parameter can also be displayed, as vectors.
   @* @b{Show grid}. Toggle the grid.
   @* @b{Show markers}. Show the handles for markers, which are 2D parameter
      values. The handles can be dragged to adjust those parameters.
   @* @b{Show S parameters}. Show the computed S-parameters for all ports in
      the model.
   @* @b{Antialiasing}. Render the model and field more smoothly, using
      anti-aliasing. On some platforms this can be slow, and so can be switched
      off.
   @* @b{Switch to model after each solve}. When this option is turned off,
      each time a new field solution is computed the model tab is made visible.
      Turn this option off to allow other tabs to remain visible.
   }
@* @b{Solve}
   @list{
   @* @b{Sweep}. Plot S-parameters or other values over parameter values.
      See the section on @link{sweeps}{sweeps}.
   @* @b{Select optimizer}. Select the numerical technique that will be used to
      perform optimizations. For certain problems some techniques perform
      better than others. Options are Levenberg Marquardt, and Subspace dogleg.
   @* @b{Start optimization}. Adjust the selected parameters to improve the
      output of the @c{config.optimize} function.
      See the section on @link{optimization}{optimization}.
   @* @b{Stop sweep or optimization}. Abort the current sweep or optimization,
      in case it is taking too long.
   @* @b{Run test() after each solve}. After each solve, run the
      @c{config.test} function.
   }
@* @b{Help}
   @list{
   @* @b{Rama manual}. Open a web brower at the Rama manual.
   @* @b{Rama website}. Open a web brower at the Rama website.
   @* @b{Lua manual}. Open a web browser at the Lua manual.
   @* @b{Check for latest version}. Check to see if there is a new version
      of Rama.
   }
}

#############################################################################
@section{Tutorial}


# @@@ Sweeps?
# @@@ Multi-frequency?
# @@@ Radiation patterns?
# @@@ VSWR visualization


#############################################################################
@section{Lua scripting}

Simulations in Rama are driven by Lua scripts that specify the boundary of
the cavity, the locations of ports, any dielectric materials, and other
parameters. Here's the
@link{http://www.lua.org/manual/5.4/manual.html}{reference manual} for Lua,
which explains the structure of the language. That has much more detail than
you actually need to run Rama, a gentler introduction is the book
@link{http://www.lua.org/pil/}{Programming in Lua}. An older version of that
book @link{http://www.lua.org/pil/contents.html}{is available online} and is
still 100% relevant as Rama does not use any advanced Lua features.

@subsection{The config table}

The job of the script is to create a Lua table called @c{config} that contains
the following fields:

@table{

  @* @c{type}
  @| The type of cavity to simulate: @c{'S'}, @c{'Exy'}, @c{'Ez'}, @c{'TE'} or
     @c{'TM'}.

  @* @c{unit}
  @| The distance unit to use for all geometry numbers. Options are @c{'nm'},
     @c{'micron'}, @c{'mm'}, @c{'cm'}, @c{'m'}, @c{'km'}, @c{'mil'} and
     @c{'thou'} (both mean 0.001 inch), @c{'inch'}, @c{'foot'}, @c{'yard'},
     @c{'mile'}.

  @* @c{cd}
  @| The geometry of the ``computational domain''. This is a shape object that
     specifies the boundary polygon, dielectric regions, and the location of
     ports. Usually most of the script is concerned with creating this object
     (see the section on @link{shapes}{shape objects}).

  @* @c{frequency}
  @| The frequency in Hz to run the simulation at. This is a single number for
     a single-frequency simulation. For a multi-frequency simulation this is
     an array of frequencies.

  @* @c{mesh_edge_length}
  @| The maximum edge length of the mesh (in the above units). This should
     usually be no larger than 1/10 of the wavelength. Smaller numbers here
     result in finer meshes that will have more accurate solutions but which
     will take longer to solve.

  @* @c{mesh_refines}
  @| The number of mesh refinement steps to take. This is currently ignored.

  @* @c{excited_port}
  @| If this is an integer @m{\ge 1}, the port to inject a signal on.
     If this is an array @c{@{}@m{m_1,\phi_1,m_2,\phi_2,\ldots}@c{@}} then
     @m{m_i,\phi_i} specifies the magnitude (not power) and relative phase (in
     degrees) of the signal to inject on port @m{i}.

  @* @c{depth} (optional)
  @| The depth (in the above units) of @c{Exy} cavities. This is not used for
     the other cavities as their solutions are independent of depth.
     The depth can be set to @c{Infinity} to model free space, with
     solutions that are independent of Z.

  @* @c{optimize} (optional)
  @| When optimization is performed the optimizer calls this function. It is
     defined as:
@===[
  optimize=function(port_power, port_phase, field)
    ...
    return error1,error2, ...
  end
]===@
  The arguments are arrays of powers (in Watts) and phases (in radians) for
  each defined port, and a @c{field} table that allows the field solution to be
  interrogated. The return values are one or more error values. The goal of
  optimization is to get the errors as close to zero as possible.

  The @c{field} table contains functions that can be called with x,y
  coordinates to return various field-derived quantities:
@===[
  field.Select(n)       -- Select field for frequency n (1..#config.frequency)
                        -- All functions below return values for this frequency
  field.SolveAll()      -- A hint that Select will be called for all n.
                        -- This pre-solves the fields in parallel, for speed
  field.Ports()         -- The port_power,port_phase for the selected field
  field.Complex(x,y)    -- field components as a complex number
  field.Magnitude(x,y)  -- magnitude of the field
  field.Phase(x,y)      -- phase of the field (in radians)
  field.Poynting(x,y)   -- x,y components of Poynting vector (2 return values)
  field.Power(x,y)      -- magnitude of the Poynting vector
  field.Pattern(theta)  -- antenna power (in W) at angle theta (in degrees)
  field.Directivity()   -- antenna directivity (max power / avg power)
]===@
  If the returned error or its derivatives are infinity or NaN (i.e. undefined)
  for the current parameters then the optimizer will not step into this region.
  If this happens too many times then the optimizer will give up and return
  a sub optimal result. This can happen in various ways, including
  @list{
  @* Using port power or phase when zero power is delivered to the port, e.g.
     because it is cut off from the excitation by a geometry error.
  @* Using the @c{Magnitude}, @c{Phase} or @c{Power} functions where the
     field is zero.
  @* Using the @c{Pattern} or @c{Directivity} functions without a radiation
     boundary.
  }

  If @c{config.optimize} is defined it is also called once for each regular
  (non-optimization) run of the script, to help verify the function contains no
  runtime errors. For these calls the @c{field} functions may return zeros.

  @* @c{test} (optional)
  @| When the ``Run test() after each solve'' checkbox is ticked, the @c{test}
     function is called every time a new solution is created. It has exactly
     the same arguments as @c{optimize}:
@===[
  test=function(port_power, port_phase, field)
    ...
    return value1,value2,...
  end
]===@
  The @c{test} function can optionally return values, that can be plotted
  during a sweep. It can also send output to the script messages tab using
  either @c{print} or @c{error}. This function is callable when parameters are
  changed, during sweeps, and optimizations.
  The @c{test} feature can be used to generate reports, and it is also used as
  part of the internal Rama unit test system.

  @* @c{antenna_pattern} (optional)
  @| For antenna simulations, the way in which the far field antenna pattern
     will be computed. Options are
     @list{
     @* @c{"at_ABC"}, which means that the far field will be computed at the
        exterior of the computational domain, where ever there is an ABC
        boundary. This is the default.
     @* @c{"at_far_field_material"}, which means that the far field will be
        computed at the boundary between regular materials and those that have
        the @c{util.FAR_FIELD} color bit. PML materials are created with this
        bit.
     @* @c{"at_boundary"}, which means that the far field will be computed at
        the exterior of the computational domain, regardless of boundary type.
     }

  @* @c{boresight} (optional)
  @| For antenna simulations, the angle that is nominally the highest gain part
     of the beam. This angle becomes the zero-azimuth on the antenna pattern
     plot. This angle is in degrees, 0 is towards the right and 90 is up. If
     this is not specified it defaults to 0.

  @* @c{max_modes}
  @| For @c{TE} and @c{TM} type, this is the number of modes to compute.

  @* @c{wideband_window}
  @| For a multi-frequency simulation this is the scaling window that is used
     to display wideband pulses. Valid values are @c{rectangle} and @c{hamming}.
     If this field is missing then a rectangular window is assumed.
}

@subsection{Parameters}

The geometry and other parameters of most models will be driven by parameters.
Parameters are numerical values that the user can easily adjust via text boxes
and sliders in a panel on the user interface:

@figure{parameters.png}{}

Parameters are easy to use from within the script. For each parameter you want,
call the @c{Parameter()} function like this:

@===[
  value = Parameter{label='Some text', min=0, max=3, default=1}
]===@

The @c{label} is displayed next to the parameter's text box and slider. Each
parameter must have a different label. The bounds of the parameter, i.e. its
minimum and maximum value are specified in @c{min} and @c{max}. The initial
value of the parameter is specified by @c{default} (which must be between
@c{min} and @c{max}). The returned @c{value} of the @c{Parameter()} function is
the current value of the parameter. The first time the script is run this will
be the @c{default}, but when the user changes the parameter the script will be
re-run, @c{Parameter()} will return the new value and an updated solution will
be computed for any new geometry.

By default parameters can take any real value. Parameters that are restricted
to integers can be generated by:

@===[
  count = Parameter{label='Count', min=1, max=10, default=1,
                    integer=true}
]===@

If you have many parameters it can be useful to put them into groups. A
horizontal line to separate groups can be generated by calling
@c{ParameterDivider()}.

Parameter values can be used to control shapes, or for anything else. For
example it is common to use parameters in the @c{config} table to allow
configuration values to be controlled, like this:

@===[
  config = {
    frequency = Parameter{label='Frequency (Hz)', min=10e9,
                          max=20e9, default=15e9},
    excited_port = Parameter{label='Excited port', min=1, max=4,
                             default=1, integer=true},
    ...
  }
]===@

If the "Reload resets parameters to script defaults" checkbox is checked then
parameters are reset to their default values each time the script is loaded
from disk. If it's not checked then parameters keep their current values
(actually they take the value of whatever parameter last had the same label,
even if the parameter order changed, as long as the min and max values are
consistent).

@subsection{Parameter defaults}

The @c{default} argument to the @c{Parameter@{@}} function is actually optional.
If it is not given, the default value will be read from the global
@c{default_parameters} table using the parameter label as a key, if that table
and key exists. If that table or key doesn't exist the parameter will take the
@c{min} value. This mechanism allows easy copying of the current parameter
values back into the script: simply select Edit/Copy from the menu (or press
Ctrl+C) and the current parameters will be copied to the clipboard in this
form:

@===[
  default_parameters = {
    ['Point x'] = 0.12,
    ['Point y'] = 0.54,
    ...
  }
]===@

This block of text can be pasted back into the script so that parameters can
acquire their defaults from it.


@subsection{Markers}

It is common to have parameters that are actually the x,y coordinates of some
point within a shape. Such parameters pairs can be generated automatically and
controlled by clicking and dragging on-screen markers, as shown here:

@figure{markers.png}{}

To create a marker you call the @c{ParameterMarker@{@}} function like this:

@===[
  x,y = ParameterMarker{label='Point', min={-1,-1}, max={2,2},
                        default={0.5,0.5}}
]===@

The @c{min}, @c{max} and @c{default} arguments are similar to @c{Parameter@{@}}
except that a table of x,y coordinates is given instead of a number. The
@c{label} is suffixed with ``x'' and ``y'' to create two new parameters. Those
parameters can be adjusted by text box, slider, or by clicking and dragging the
marker. @c{ParameterMarker@{@}} returns both the x and y parameters values.
Note that Lua allows those values to be passed directly as two arguments of
another function, so for example the following is a convenient idiom:

@===[
  shape:AddPoint(ParameterMarker{...})
]===@

@subsection{Functions and variables accessible to the Lua script}

The following @link{http://www.lua.org/manual/5.4/manual.html}{Lua standard libraries}
can be used: base, table, string, utf8 and
math. The standard Lua @c{print()} function sends text to the ``script messages''
tab. The standard Lua @c{error()} function will output its error message to this
tab also. The following extra miscellaneous functions are defined:

@table{
  @* @c{Draw(s)}
  @| For debugging, draw the shape @c{s} to the simulation window. The shape
     will not be simulated. This can be used (for example) to check
     intermediate stages of shape creation.

  @* @c{DrawText(x,y, @_@~@~@~s,ha,va)}
  @| For debugging, draw the string @c{s} at @c{x},@c{y} in the simulation
     window. The optional @c{ha} argument is the horizontal alignment of the
     text which can be @c{'center'}, @c{'right'} or the default @c{'left'}.
     The optional @c{va} argument is the vertical alignment of the
     text which can be @c{'top'}, @c{'bottom'}, @c{'center'} or the default
     @c{'baseline'}.

  @* @c{math.log10(x)}
  @| The standard @m{\log_{10}} function, an addition to the math library
     because it is not defined by Lua. It is useful for computing things in
     decibels.
}

In addition to the standard Lua global variables, the following are available:

@table{
  @* @c{FLAGS}
  @| A table populated with any @c{-key=value} arguments given on the command
     line. This is useful for testing. For example if @c{-test_number=5} is
     given on the command line then @c{FLAGS.test_number} will return the value
     @c{'5'} (note that this is the string @c{'5'} and not the number 5).
}

@subsection{@label{vectors} Vectors}

Rama Lua supports vectors in addition to real numbers. Vectors are
arrays of numbers that are treated as a single block by math operators.
Vector are mostly used by @link{dielectrics}{dielectric callback functions},
for efficiency reasons. Below are the operations and functions available for
vectors (@c{a} and @c{b} are vectors of the same size and @c{k} is a real
number).

@table{
  @* @c{a + b}, @c{a - b}, @_
     @c{a * b}, @c{a / b}, @_
     @c{a ^ b}
  @| The element-wise sum (product, etc) of @c{a} and @c{b}. This result is a
     vector of the same size as @c{a} or @c{b}.
  @* @c{a + k}, @c{k + a}, etc.
  @| The element-wise sum of @c{a} and @c{k}. This result is a vector of the
     same size as @c{a} (and likewise for the other operators).
  @* @c{Vector()}
  @| Create a new zero-sized vector.
  @* @c{@#a}
  @| The number of elements in @c{a}.
  @* @c{a:Resize(n)}
  @| Resize the vector to have @c{n} elements. All elements will be set to
     zero. Return @c{a}, so that @c{v = Vector():Resize(n)} can be written.
  @* @c{a[i]}
  @| Access the @c{i}'th element of @c{a}, where @c{i} is in the range
     @c{1...@#a}.
  @* @c{vec.abs(a)},@~@c{vec.acos(a)}, @_
     @c{vec.asin(a)},@~@c{vec.atan(a)}, @_
     @c{vec.atan2(a,b)},@~@c{vec.ceil(a)}, @_
     @c{vec.cos(a)},@~@c{vec.exp(a)}, @_
     @c{vec.floor(a)},@~@c{vec.fmod(a,b)}, @_
     @c{vec.log(a)},@~@c{vec.log10(a)}, @_
     @c{vec.sin(a)},@~@c{vec.sqrt(a)}, @_
     @c{vec.tan(a)}
  @| Math functions on vectors, similar to the regular functions in the
     Lua math library. The @c{atan} function accepts one argument or two
     as in Lua 5.3, the @c{atan2} function accepts two arguments as in Lua 5.0.
  @* @c{vec.eq(a,b)} @| A vector with ones where @m{a = b} and zero otherwise.
     Named comparison functions are used for elementwise comparison instead of
     overloading the comparison operators, because the latter can only return
     single bools.
  @* @c{vec.ne(a,b)} @| A vector with ones where @m{a \ne b} and zero otherwise.
  @* @c{vec.lt(a,b)} @| A vector with ones where @m{a < b} and zero otherwise.
  @* @c{vec.gt(a,b)} @| A vector with ones where @m{a > b} and zero otherwise.
  @* @c{vec.le(a,b)} @| A vector with ones where @m{a \le b} and zero otherwise.
  @* @c{vec.ge(a,b)} @| A vector with ones where @m{a \ge b} and zero otherwise.
  @* @c{vec.IsVector(a)} @| True if @c{a} is a vector, false otherwise.
}

@subsection{@label{complex} Complex numbers}

Rama Lua supports complex numbers in addition to real numbers. The real and
imaginary parts of the complex numbers can be either real numbers or vectors.
Below are the operations and functions available for complex numbers
(@c{a} and @c{b} are complex numbers, @c{k} is a real number and @c{v} is
a vector).

@table{
  @* @c{Complex(re,im)}@_@c{Complex(re)}
  @| Create a new complex value from the real and (optionally) imaginary
     parts, which are either both real numbers or both vectors of the same
     size.
  @* @c{a + b}, @c{a - b}, @_
     @c{a * b}, @c{a / b}, @_
     @c{a ^ b}
  @| The complex sum (product, etc). The values @c{a} and @c{b} must be
     compatible in the sense that their real and imaginary parts must either
     both be real numbers or both be vectors of the same size.
  @* @c{a + k}, @c{k + a}, etc.
  @| The sum of complex value @c{a} and real number @c{k} (and likewise for the
     other operators).
  @* @c{a + v}, @c{a * v}, etc.
  @| The sum (product, etc) of complex value @c{a} and vector @c{v}, which
     must be compatible.
     In binary operations the complex value @c{a} must appear before the
     vector @c{v} to ensure @c{v} is treated as the real part of a complex
     vector. Due to the way overloaded operators work in Lua, if @c{v} appears
     first then @c{a} will be treated as a vector, which will fail.
  @* @c{a.abs}
  @| The absolute value or magnitude of @c{a}.
  @* @c{a.angle}
  @| The angle of @c{a} in radians.
  @* @c{a.re}, @c{a.im}
  @| The real and imaginary parts of @c{a}.
  @* @c{complex.exp(a)}
  @| Math functions on complex numbers or vectors, similar to the regular
     functions in the Lua math library.
}

@subsection{Programming style}

At the end of the script it is a good idea to do these things:

@list{

@* Check the geometry to make sure it has the expected number of pieces, e.g.:
@===[
  assert(config.cd.pieces == 3)
]===@

}

#############################################################################
@section{@label{shapes} Shape objects}

A shape object represents the 2D geometry of the computational domain. It
contains the boundary polygons, dielectric regions, and the location of ports.
The parts of the shape polygon that are not ports usually represent metal
walls. Shapes can be created in a variety of ways using the functions below. A
common strategy is to perform ``constructive solid geometry'', i.e. take
primitive shapes such as rectangles and combine them with union, intersection
and subtraction operations.

Internally a shape is a set of one or more 2D polygons (each polygon is
referred to as a ``piece''). Each piece has three or more vertices. Polygons
can either represent outer boundaries or interior holes. Outer boundary
polygons have positive area and their vertices wind in a counterclockwise
direction. Interior holes have negative area and their vertices wind in a
clockwise direction.

A special case is ``polylines'', which are polygons with zero area that have
coordinates in the sequence @m{p_1,p_2,\ldots,p_{n-1},p_n,p_{n-1},\ldots,p_2}.
These polygons are not useful as shapes for computational domains, but are
useful to pass to the @c{Grow()} function to make ``fat polylines''.

@subsection{Shape primitives}

The following global functions will create the standard primitive shapes:

@table{
  @* @c{Circle(x,y,radius,npoints)}
  @| Return a circle shape with the given @c{radius} and @c{npoints} vertices,
     where (x,y) is the center of the circle.

  @* @c{Rectangle(x1,y1,x2,y2)}
  @| Return a rectangle shape with 4 vertices, where (x1,y1) and (x2,y2) are
     vertices on diagonally opposite corners.

  @* @c{Shape()}
  @| Return a new, empty shape. This is useful when @c{AddPoint()} is used to
     create a shape directly from vertices.
}

Shapes can be created vertex-by-vertex using @c{AddPoint()}. For example, to
create a triangle from the points (x1,y1), (x2,y2), and (x3,y3) you can do
this.

@===[
  triangle = Shape():AddPoint(x1,y1):AddPoint(x2,y2):AddPoint(x3,y3)
]===@

Note that all shapes must contain at least three vertices. If the vertices wind
in an anticlockwise manner the new shape will have positive area, and vice
versa. The shape union operator (@c{A+B}) currently only works with shapes that
have positive area.

@subsection{Shapes are copy-by-reference}

Lua variables contain @emph{references} to shapes, not the shapes themselves.
Forgetting this fact can lead to unexpected errors, e.g.:

@===[
  q = Rectangle(0, 0, 1, 1)     -- q is a new rectangle shape
  r = q                         -- r is that same shape, not a copy
  q.Offset(10, 10)              -- q is moved, and so is r!
]===@

If you want to have two copies of a shape and change them independently, you
can do this:

@===[
  q = Rectangle(0, 0, 1, 1)     -- q is a new rectangle shape
  r = q:Clone()                 -- r is a copy (or "clone") of q
  q.Offset(10, 10)              -- q is moved, r stays the same
]===@

@subsection{Accessing piece polygons and vertices of shapes}

If you have a shape object @c{s} then its polygon pieces and vertices can be
referenced with the following syntax:

@table{
  @* @c{s.pieces}
  @| The number of polygon pieces in this shape (0 for an empty shape).
     Disjoint polygons and interior holes count as separate pieces.

  @* @c{s(n)}
  @| A new shape that contains just the @c{n}'th piece of @c{s}, where @c{n} is
     in the range 1 to @c{s.pieces}.

  @* @c{@#s}
  @| The number of vertices for a single piece shape, or 0 for an empty shape.
     It is an error if @c{s} has more than once piece.

  @* @c{s[n]}
  @| The @c{n}'th vertex of a single piece shape, where n is in the range 1 to
     @c{@#s}. It is an error if @c{s} has more than once piece. The vertex is
     returned as a table containing number fields @c{x} and @c{y}.
}

For example, the following program prints out all pieces and vertices in @c{s}:

@===[
  for i = 1,s.pieces do
    print('Piece', i, 'has', #s(i), 'vertices:')
    for j = 1,#s(i) do
      local v = s(i)[j]
      print('  Vertex', j, '=', v.x, v.y)
    end
  end
]===@

@subsection{Shape information}

If you have a shape object @c{s} then:

@table{
  @* @c{s.area}
  @| A number that is the total area of the shape (i.e. outer boundaries minus
     interior holes). For single piece polygons, positive areas are returned for
     outer boundaries and negative areas are returned for interior holes

  @* @c{s.bounds}
  @| A table containing the bounding box of the shape in the form
     @m{\{\min_x, \min_y, \max_x, \max_y\}}. It is an error if @c{s} is empty.

  @* @c{s.empty}
  @| @c{true} if the shape has no polygons, @c{false} if this is a valid shape.

  @* @c{s.orientation}
  @| @c{true} if this is an outer boundary or @c{false} if this in an interior
     hole. It is an error if the shape does not have a single piece.
}

@subsection{Shape operators}

If @c{A} and @c{B} are two shapes then a third shape can be created by:

@table{
  @* @c{A + B}
  @| The union of @c{A} and @c{B}.
  @* @c{A - B}
  @| The subtraction of @c{B} from @c{A}.
  @* @c{A * B}
  @| The intersection of @c{A} and @c{B}.
  @* @c{A ~ B}
  @| The xor of @c{A} and @c{B} (i.e. points in @c{A} or @c{B} but not both).
     This is rarely used.
}

It is an error if @c{A} and @c{B} both contain port callback functions for the
same port numbers.

@subsection{Shape object geometry functions}

A shape object @c{s} can be modified or interrogated by the following
functions. Note that shape functions that don't return some other value will
return @c{s}, allowing such functions to be chained together. For example, to
rotate @c{s} about (3,4) you could do this:

@===[
  s:Offset(-3,-4):Rotate(theta):Offset(3,4)
]===@

@table{
  @* @c{s:AddPoint(x,y)}
  @| Adds the point (x,y) to the end of the last polygon piece. This is used to
     create new shapes from a list of coordinates. Returns @c{s}.

  @* @c{s:APointInside()}
  @| Returns two numbers (x,y) that are a point guaranteed to be inside the
     shape. This requires @c{s} to be a nonempty single piece polygon of any
     orientation, or a single positive area polygon with any number of negative
     area holes. Other cases are not handled and result in an error.

  @* @c{s:ChamferVertex(x,y, @_@~@~predist,postdist)}
  @| Add a chamfer of the given pre- and post-vertex distances to the vertex
     closest to @c{x},@c{y}. It is a runtime error if the shape is empty.

  @* @c{s:Clean(threshold)}
  @| Remove all vertices from shape polygons that are closer than @c{threshold}
     to adjacent vertices. Cleaning is automatically done on the final
     @c{config.cd} shape to avoid making meshes with extremely small triangles.
     It is however occasionally necessary to clean intermediate shapes.

  @* @c{s:Clone()}
  @| Returns a new copy of @c{s} so that @c{s} and its copy can be changed
     independently.

  @* @c{s:Contains(x,y)}
  @| Returns @c{true} if the point (x,y) is inside the shape (but not inside
     one of its holes) or @c{false} otherwise.

  @* @c{s:FilletVertex(x,y, @_@~@~radius,limit)}
  @| Add a fillet of the given @c{radius} to the vertex closest to @c{x},@c{y}.
     The @c{limit} is the maximum distance allowed between a polygon
     approximation of an arc and a true circle. It is a runtime error if the
     shape is empty.

  @* @c{s:Grow(delta,style,limit)} @_
     or @_
     @c{s:Grow(delta,style,limit, @_@~@~endcap_style)}
  @| Grows or shrinks the shape by distance @c{delta}. The style is
     @c{'square'}, @c{'round'} or @c{'miter'}. For the miter style, @c{limit} is the
     @link{http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Classes/ClipperOffset/Properties/MiterLimit.htm}{miter limit}
     (e.g. 2). For the round style, @c{limit} is the maximum distance allowed
     between a polygon approximation of an arc and a true circle. Port vertices
     will only be mitered (without limit) and any ports that end up being
     merged will be erased. This only works with @c{area}@m{\ge 0} polygons.
     The optional @c{endcap_style} is for the ends of polylines, and it can be
     @c{'square'}, @c{'round'}, or @c{'butt'}. Returns @c{s}.

  @* @c{s:MakePolyline()}
  @| Turn the last piece of this shape into a polyline by adding points
     @c{s[@#s-1]...s[2]} to the polygon. This makes a zero area polygon to
     represent the polyline.

  @* @c{s:MirrorX(x)}
  @| Flips the shape around the vertical line x=@c{x}. Returns @c{s}.

  @* @c{s:MirrorY(y)}
  @| Flips the shape around the horizontal line y=@c{y}. Returns @c{s}.

  @* @c{s:Offset(x,y)}
  @| Offsets the shape horizontally and vertically by @c{x} and @c{y}. Returns
     @c{s}.

  @* @c{s:Reverse()}
  @| Reverses the orientation of all polygon pieces so that their areas change
     sign. This is done by reversing their vertex lists. Returns @c{s}.

  @* @c{s:Rotate(theta)}
  @| Rotates the shape around the origin by the angle @c{theta} (in degrees).
     Returns @c{s}.

  @* @c{s:Scale(factor)} @_
     @c{s:Scale(factorx, factory)}
  @| Scales the shape around the origin by the given scale @c{factor} (e.g. 2
     doubles the size of the shape). If two scale factors are provided then
     X and Y can be scaled separately. Returns @c{s}.

  @* @c{s:Select(x,y)}
  @| Returns a selection table for the polygon edge that is closest to (x,y).
     The selection table is @c{@{p,e@}} where @c{p} is the piece number and
     @c{e} is the edge number.

  @* @c{s:Select(x1,y1,x2,y2)}
  @| Returns a selection table for all polygon edges that intersect the
     rectangle (x1,y1,x2,y2). The selection table is an array of @c{@{p,e@}}
     tables.

  @* @c{s:SelectAll()}
  @| Returns a selection table for all polygon edges in the shape. The
     selection table is an array of @c{@{p,e@}} tables.
}

@subsection{Defining ports}

Ports are specified on a shape @c{s} by first selecting one or more shape edges
using @c{s:Select()} or @c{s:SelectAll()}, then calling one of the following
functions:

@table{
  @* @c{s:ABC(sel_table)}
  @| Given a selection table @c{sel_table} specifying one or more shape edges
     in @c{s}, mark all those edges as an absorbing boundary condition (an
     ``ABC'').
  @* @c{s:Port(sel_table,n)}
  @| Given a selection table @c{sel_table} specifying one or more shape edges
     in @c{s}, mark all those edges as belonging to port @c{n}, where
     @c{n}@m{\ge 1}.
  @* @c{s:Port(sel_table,n,@_@~@~function(d,x,y)@_@~@~@~@~return @m{\alpha},@m{\beta}@_@~@~end)}
  @| Similar to the @c{Port()} function above, but also use a function that is
     given a vector @c{d} of edge distances, corresponding vectors @c{x} and
     @c{y} of point coordinates, and computes corresponding vectors of boundary
     @m{\alpha} and @m{\beta} values. The return vectors can be complex. Each
     edge has distance @c{d} going from 0 to 1 as we traverse the polygon
     counter clockwise. This feature allows arbitrary boundary constraints and
     boundary excitations. For convenience, the @m{\alpha} and @m{\beta} values
     are multiplied by the wavenumber @m{k} before being used in the
     simulation.
}

@subsection{@label{dielectrics} Dielectrics}

Shapes by themselves define metal walls of a cavity, or ports or other boundary
conditions. The space between the walls is vacuum by default (or you can regard
this as air). Other materials with different dielectric constants or
Schrödinger potentials can be inserted into the cavity. These dielectrics are
represented as ``painted'' regions within shapes. The ``paint'' that is used
has an actual visible color (so that the area can be identified on screen),
a relative epsilon (@m{\epsilon}) or potential value, and other parameters.

The following functions can be used to define dielectrics in shape @c{s}:

@table{
  @* @c{s:Paint(q,col,@m{\epsilon})}
  @| Paint a new dielectric into @c{s}. The painted area is shape @c{q}, which
     should intersect @c{s}. The on-screen color used to represent this is
     @c{col}, which is an @c{0xrrggbb} color constant. The relative epsilon
     value of the dielectric is @m{\epsilon} (e.g. for air @m{\epsilon=1}).
     The @m{\epsilon} value can be a @link{complex}{complex} number.
     For Schrödinger cavities @m{\epsilon} is actually the potential "@m{V}".

  @* @c{s:Paint(q,col,@m{\epsilon},@_@~@~@m{\sigma_{xx}},@m{\sigma_{yy}},@m{\sigma_{xy}})}
  @| Similar to the @c{Paint()} function above except that the sigma values
     for anisotropic dielectrics are also specified. If the sigma values are
     not given then the default is the isotropic case
     @m{\sigma_{xx}=\sigma_{yy}=1, \sigma_{xy}=0}.
     Each of the @m{\epsilon,\sigma_{xx},\sigma_{yy},\sigma_{xy}} values can be
     a real number or @link{complex}{complex} number.

  @* @c{s:Paint(q,col,@m{\epsilon},@_@~@~@m{\sigma_{xx}},@m{\sigma_{yy}},@m{\sigma_{xy}},@m{f})}
  @| Similar to the @c{Paint()} function above except that the excitation value
     @m{f} is also specified. It can be a real number or
     @link{complex}{complex} number. If @m{f} is not given then the default is
     zero. To scale @m{f} so that @c{q} emits amplitudes similar to ports,
     use a scale for @m{f} similar to @c{util.KinM()/short_dimension_of_q_in_meters}.

  @* @c{s:Paint(q,col,function(x,y)@_@~@~...@_@~@~return @m{\epsilon},@m{\sigma_{xx}},@m{\sigma_{yy}},@m{\sigma_{xy}},@m{f}@_end)}
  @| Similar to the @c{Paint()} function above except that the @m{\epsilon},
     @m{\sigma}, and @m{f} values are specified with a function that takes
     @c{x,y} coordinates and returns those values. The @m{\sigma} and @m{f}
     values are optional (although if @m{f} is given then the @m{\sigma} values
     must be given too). Each return value can be a real or complex number.
     For performance reasons @c{x,y} are vectors of coordinates and the
     returned values must be vectors of the same size. See the section on
     @link{vectors}{Vectors}.
}

In the current implementation of @c{Paint()} the shape is split into several
unmerged pieces with different material properties, so the shape piece and
vertex access functions may return unexpected results after painting.

@emph{Also note that in the current implementation of dielectrics, if
dielectric-containing shapes are combined with others using the
@c{+},@c{*},@c{-},@c{~} operators then the dielectric regions will be erased.
This limitation will be corrected in a future version. This means that painting
should generally be one of the last steps in model creation.}

@subsection{Utility functions}

@table{
  @* @c{MakeMachinable(shape, @_@~@~radius, limit)}
  @| Returns a ``machinable'' version of shape, assuming a cutting tool of the
     given @c{radius}. If @c{radius} > 0 then the shape is assumed to be a
     pocket machined out of some larger slab. If @c{radius} < 0 then the shape
     is assumed to be a plate machined from the outside. The @c{limit} is the
     maximum distance allowed between a polygon approximation of an arc and a
     true circle.
  @* @c{LinearRange(start,stop,n)}
  @| Return an array of @c{n} numbers linearly distributed between @c{start}
     and @c{stop}.
  @* @c{Min(a, b)}
  @| Return the minimum of the values a and b.
  @* @c{Max(a, b)}
  @| Return the maximum of the values a and b.
}

#############################################################################
@section{Sweeps and Optimization}

@subsection{@label{sweeps} Sweeps}

[TODO: write this]

@figure{PlotExample.png}{}

Within the plot window, zoom in by left-clicking and dragging to select an area
of the plot. Zoom out to the previous view by right-clicking.

@@@@@@ Another way:
The "S Params" tab is a plot that shows S parameters over frequency, for
multi-frequency solves.

@subsection{@label{optimization} Optimization}

TODO: write me. NOTES:
@list{
@* Select parameters to optimize
@* The ``invisible hand'' concept.
@* How to write the @c{optimize()} function: don't square things, split
   separate objectives into multiple return values.
}

#############################################################################
@section{Multi-frequency solves}

Often @c{config.frequency} is a single number, and each field solution is for
that particular frequency. However @c{config.frequency} can be an array of
numbers to solve for multiple frequencies simultaneously. There are two reasons
to want this: wideband optimization and pulse visualization.

@subsection{UI controls}

If the current model has multiple frequencies then the "Frequency" spinner and
slider at the top of the model window will be enabled, letting you select which
of the solutions is currently displayed.

Many functions in Rama will apply only to the currently displayed solution: for
example, sweeps and the antenna plot.

The "S Params" window plots the S parameters across all the frequencies in the
model. However if an S parameter plot is all that is desired it is generally
simpler to use the Sweep command to sweep a frequency paramater.
Computing multiple frequencies can be slower per update, as the model needs to
be solved multiple times.

@subsection{Wideband optimization}

If @c{config.frequency} is an array of more than one frequency, the
@c{config.optimize} function can query the solution for each frequency
independently. Optimizing the model for multiple frequencies simultaneously can
result in models with wider bandwidth. For example, when @c{config.optimize}
returns the worst return loss over all frequencies, that tends to minimize the
return loss over the entire bandwidth.

The @c{port_power} and @c{port_phase} arguments to @c{config.optimize} are just
for the currently displayed solution. To query other solutions use the
@c{field.Select(n)} function to select the frequency that subsequent field
functions will apply to.
The @c{field.Ports()} function will return the arrays of @c{port_power} and
@c{port_phase} that correspond to the currently selected solution.

@subsection{Pulse visualization}

If the "Wideband pulse" checkbox is ticked and the model has solutions for
multiple frequencies then the displayed field is all solutions added together.
This results in a pulse, i.e. a short time burst of energy. In many situations
it can be instructive to look at how a pulse propagates through the system.
The width and duration of the pulse is controlled by the total bandwidth and
number of values in @c{config.frequency}.

When animating the pulse each solution is advanced in phase by the appropriate
amount so the pulse stays coherent. Unlike the single frequency solution, the
displayed field does not repeat for every turn of the time dial.
The "Set animation time to 0" command can be used to reset the pulse to its
starting state.

There is one subtlety to consider when displaying pulses. The weight given to
the solution for each frequency can be controlled to minimize the side lobes
of the pulse. This is controlled by @c{config.wideband_window}, which selects
a window function that provides the weights.

#############################################################################
@section{Waveguide modes}

When @c{config.type} is @c{TE} or @c{TM} the TE or TM waveguide modes are
computed.
The number of modes computed is given by @c{config.max_modes}.
For each mode the cutoff frequency is displayed.
The display selection box allows various components of the E and H fields to
be displayed.

When the cutoff frequencies of two modes are very close to each other (or
identical) the mode fields recovered will be some linear superposition of
whatever you think the ``official'' modes should look like. E.g. for TM modes
in a rectangle with 2:1 aspect ratio, modes 4 and 5 will have this issue. The
best that the mode solver can do is find an orthogonal subspace for all modes
with the same cutoff frequency.

#############################################################################
@section{Modeling}

@subsection{Modelling tips}

Here are suggestions for how to make models that best describe a real physical
setup.

Notes for now:
@list{
@* Use a smaller mesh size for better accuracy.
@* Don't violate the @m{TE_{10}} mode assumption at ports, i.e. use an
   appropriate width and keep this width for a short distance.
}

@subsubsection{Coordinates}

To help deal with geometrical tolerancing issues within Rama, shape coordinates
have a limited resolution. There are effectively 32 bits to the left and right
of the decimal point. This quantizes coordinates to @m{2.3\times10^{-10}} and
gives us a maximum coordinate of @m{\pm 2.1\times10^9}. This is generally not a
problem: for @c{config.unit} set to meters, the quantization size is on the
order of the atomic spacing in a crystal lattice. This does mean however that
you should chose @c{config.unit} appropriately for your problem. For example,
don't create a circle the diameter of the Earth in microns, because that's
@m{1.3\times 10^{13}}. Use miles or kilometers instead.

@subsection{Rama model errors}

Here are things that Rama does not yet model. Correct modeling of these things
may be implemented later, if there is need.

@list{
@*  Painting of dielectrics does not work in @c{Exy} cavities with finite
    depth. Areas can be painted, and this will affect the solution, but the
    solution will not satisfy Maxwell's equations and will not necessarily be
    physically meaningful. Since this situation results in a 3D field with
    complex structure, this limitation is not likely to be fixed.
@*  Painting of constant dielectric areas works in @c{Ez} cavities and @c{Exy}
    cavities with infinite depth, but painting of dielectric @emph{fields} does
    not work in @c{Exy} cavities with infinite depth. This limitation will be
    fixed once we add the dielectric term
    @m{(\nabla \epsilon/\epsilon)\times(\nabla\times H)} to the Helmholtz
    equation for such fields.
@*  Dielectric painting does not work in @c{TE} and @c{TM} cavities.
@*  Some ports on areas with non-default @m{\epsilon} or @m{\sigma} are not
    well matched. This currently happens when
    @list{
    @* The @m{\epsilon} or @m{\sigma} values have imaginary components, meaning
       there is attenuation or gain in the material.
    @* @c{Ez} models have non-default @m{\sigma} values.
    @* @c{Exy} models have non-default @m{\sigma} values and don't have a
       principle axis of the anisotropy aligned with the port.
    }
    Ports that are not well matched do not deliver or absorb energy with
    perfect efficiency. The effect is most noticeable at output ports where
    there is some reflected wave. The S parameters computed at poorly matched
    ports will not be correct.
}

#############################################################################
@section{Rama Internals}

This part of the manual is only useful if you want to do Rama software
development.

@subsection{Building from source on windows}

It is much more annoying to build on windows than on linux. We use the
@c{x86_64-w64-mingw32} toolchain on cygwin so that we can (a) use GNU source on
both linux and windows, and (b) still build native binaries on windows. The
other major option (Visual C++) would compile much faster but also require a
lot of Visual C++-specific modifications to the code. However building for
@c{x86_64-w64-mingw32} is a big pain, because it mixes gnu-isms, linux-isms and
windows-isms in a way that confuses many libraries. Therefore, many of the
libraries below have to be built with a custom processes.

@subsubsection{Prerequisites}

@list{
@* Cygwin with @c{x86_64-w64-mingw32}, make (and other packages?)
@* Matlab
@* config.mk
}

@subsubsection{Eigen}

Apply @c{eigen_patches.txt}.

Eigen blas and lapack. From the eigen source directory:
@===[
mkdir build_dir
cd build_dir
make clean && cmake .. && make -j4 CMAKE_CXX_FLAGS=-mmacosx-version-min=10.9 \
  CMAKE_C_FLAGS=-mmacosx-version-min=10.9 VERBOSE=1 blas lapack
]===@

@subsubsection{Triangle}

The triangle library converts shape polygons into mesh triangles.

@subsubsection{Clipper}
@subsubsection{Lua}
@subsubsection{Ceres}
@subsubsection{ARPACK}

@===[
./configure --disable-alloca --with-our-malloc16 --disable-shared
  --enable-static --disable-threads --enable-sse2 --host=x86_64-w64-mingw32
]===@

@subsubsection{Zlib}

@subsubsection{Matlab (optional)}

@subsubsection{Release process}

@list{
@* Update @c{__APP_VERSION__} in version.h before each binary release.
@* Run Inno Setup Compiler.
}


@subsection{Design Notes}

Just random notes for now.

The ``invisible hand'' uses idle events to trigger recurrent processing of
sweep and optimize updates while still being responsive to user input (mouse
events etc).

#............................................................................
@subsection{Computing the Jacobian}

For optimization we need to compute derivatives of the @c{config.optimize}
function with respect to the parameters. Since @c{config.optimize} has multiple
return values and there are multiple parameters we are actually computing a
jacobian matrix. Computing the jacobian numerically is
@link{http://en.wikipedia.org/wiki/Numerical_differentiation}{easy enough}, but
highly inaccurate for two reasons. First there is the classic problem of
choosing the step size @m{h} in @m{f'(x) \approx f(x+h)/h} without introducing
either truncation or floating point errors. Second, the more serious problem is
that the current mesh generator is not stable so even small changes in boundary
geometry can cause completely different meshes to be generated. This means that
the field solution (and therefore the objective function) is a little noisy.
That noise forces us to use large @m{h}, making the jacobian untrustworthy. A
bad jacobian will frustrate the ability of e.g. a Levenberg-Marquardt optimizer
to reach a good solution.

A much better approach is to compute a correct jacobian, either analytically or
using automatic differentiation. In fact we must use both approaches together,
as the Lua script contains a user defined function for which we can not figure
out analytic jacobians, and a large @m{Ax=b} solve would be slowed down too
much if each matrix element was subject to automatic differentiation.

Let's look at the complete chain of dependencies between the parameters @m{p}
and the @c{config.optimize} output. We use the chain rule to figure out
@m{d/dp} at each stage. The dependency chain is:

@numlist{
@*  Start with the parameter vector @m{p}.

@*  @m{p \rightarrow} Lua script engine @m{\rightarrow S} (the shape of
    the computational domain) and the @c{ScriptConfig}. We introduce the
    numerical type @c{JetNum} (based on @c{ceres::Jet}), which does automatic
    differentiation. The Lua interpreter is modified to accept @c{JetNum} as
    its @c{lua_Number}, meaning that derivatives with respect to parameters
    can be carried through all numeric quantities in user scripts. All point
    coordinates in shapes use @c{JetNum}, so we automatically have @m{dS/dp}.

    The main issue with this scheme is the Clipper library, which converts all
    continuous quantities into integers for its own robustness reasons, so we
    can not simply replace those integers with @c{JetNum}. However each Clipper
    integer coordinate has an associated @c{Z} value, which we modify to
    contain the required derivatives. The @c{Z} derivatives for new vertices
    introducted by Clipper are computed correctly by the Clipper
    @c{ZFillCallback}.

    For simplicity below we enforce that @c{ScriptConfig} should not depend
    on the parameters. This restriction can be relaxed later.

@*  @m{dS/dp \rightarrow} Mesher @m{\rightarrow dM/dp}, where @m{M} is the
    mesh. We must ignore the mesh length and refinement settings in
    @c{ScriptConfig} because they would substantially alter the mesh, and the
    stability of our method depends on the fact that the mesh remains
    unaltered. Therefore we enforce that @c{ScriptConfig} should not depend on
    the parameters. The continuous values in the mesh are the vertex positions
    and triangle material values (e.g. @m{\epsilon}). The other mesh values are
    triangle connectivity and port settings, discrete values which are assumed
    not to be affected by small changes in the parameters. For simplicity below
    we enforce that material settings can not depend on parameters.

    To compute @m{dM/dp} we associate boundary triangle edges to lines in
    @m{dS/dp}, then then linearly interpolate from @m{dS/dp}. We assume that as
    parameters changes only boundary triangles are affected, i.e. geometry
    changes are not propagated into interior triangles.

@*  @m{dM/dp \rightarrow} System matrix creator @m{\rightarrow dA/dp, db/dp}.
    This is done with automatic differentiation by using @c{JetNum} and
    @c{JetComplex}.

@*  @m{dA/dp, db/dp \rightarrow} Linear solver @m{\rightarrow dx/dp}.
    Given a solution to a linear problem @m{A \: x = b} and a scalar parameter
    @m{p}, we want to compute @m{dx/dp} from @m{dA/dp} and @m{db/dp}, without
    expensive refactoring of @m{A}-sized matrices. From the
    @link{http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/3274/pdf/imm3274.pdf}{Matrix Cookbook}
    we have

    @M{
      {\del A^{-1} \by \del p} &= -A^{-1} \: {\del A \by \del p} \: A^{-1}
    }

    From which we get

    @M{
      x &= A^{-1} \: b \\
      {\del x \by \del p} &= {\del A^{-1} \by \del p} \: b + A^{-1} \: {\del b \by \del p} \\
        &= -A^{-1} \: {\del A \by \del p} \: A^{-1} \: b + A^{-1} \: {\del b \by \del p} \\
        &= A^{-1} \left(  -{\del A \by \del p} \: x + {\del b \by \del p} \right)
    }

    The cost of this is one multiplication by @m{\del A / \del p} (which might
    be cheap if it is sparse) and one solve with the already-factored
    @m{A^{-1}}.

@*  @m{dx/dp \rightarrow} Compute port powers @m{\rightarrow P}, where
    @m{P} are the port powers and phase angles. This is done with @c{JetNum}.

@*  @m{P \rightarrow} output of the @c{config.optimize} function.
    This is done with @c{JetNum} within Lua.
}

Each @c{JetNum} contains the derivative with respect to just one parameter, so
the above steps have to be done once per parameter. The @c{JetNum} could
contain more derivatives but that would slow down the Lua interpreter, and we
spend most of the time doing the matrix solves anyway.

#############################################################################
@section{Rama License}

Rama is open source software that anyone is free to use and modify. It is
licensed to you under the terms of the GNU General Public License, version 3
(or @link{https://www.gnu.org/licenses/gpl-3.0.en.html}{GPLv3}).

Rama is built upon many other open source software libraries, that each have
their own licenses. Those other licenses are linked in the Rama
@link{https://raw.githubusercontent.com/Evenedric/stuff/master/rama/COPYING}{COPYING file}.
The licenses vary widely in what they permit, but the most restrictive of them
are also GPLv3.

For details of Rama's own license, please see the Rama
@link{https://raw.githubusercontent.com/Evenedric/stuff/master/rama/COPYING}{COPYING file}.
However, to summarise:

@list{
@* Anyone can use this software, free of charge. That includes private,
   educational, and commercial use.
@* Anyone can copy, modify and distribute this software.
@* If you modify this software, your modifications must also be licensed under
   GPLv3.
@* If you distribute this software, those who receive it must inherit these same
   rights and responsibilities.
@* This software is provided without any warranty.
@* The authors of this software can not be held liable for any damages inflicted
   by the software.
@* All copyrights are held by the respective authors.
}
