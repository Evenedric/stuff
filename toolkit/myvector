// Copyright (C) 2014-2020 Russell Smith.
//
// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.

// Redefine the standard std::vector to perform range checks if _GLIBCXX_DEBUG
// is defined. In fact this is the standard behavior when the GNU C++ libraries
// are used, but it doesn't happen on windows or OS X. You should include this
// header instead of <vector>, then used vector<> as you normally would.

#ifndef __TOOLKIT_MYVECTOR_H__
#define __TOOLKIT_MYVECTOR_H__

#include <vector>

namespace std {

template <class T, class A = std::allocator<T> >
struct myvector : public vector<T,A> {
  typedef typename vector<T,A>::size_type _size;
  typedef typename vector<T,A>::reference _ref;
  typedef typename vector<T,A>::const_reference _const_ref;
  myvector() : vector<T,A>() {}
  myvector(_size sz) : vector<T,A>(sz) {}
  myvector(_size sz, const T& value) : vector<T,A>(sz, value) {}
  _ref operator[](_size pos) {
    #ifdef _GLIBCXX_DEBUG
      return vector<T,A>::at(pos);
    #else
      return vector<T,A>::operator[](pos);
    #endif
  }
  _const_ref operator[](_size pos) const {
    #ifdef _GLIBCXX_DEBUG
      return vector<T,A>::at(pos);
    #else
      return vector<T,A>::operator[](pos);
    #endif
  }
};

#define vector myvector

}  // namespace std

#endif
