
#ifndef __CAVITY_H__
#define __CAVITY_H__

#include "lua_model_viewer_wx.h"
#include "shape.h"
#include "solver.h"

class Cavity : public LuaModelViewer {
 public:
  Cavity(wxWindow* parent, wxWindowID id, const wxPoint &pos,
         const wxSize &size, long style);
  ~Cavity();

  // Define abstract functions from LuaModelViewer.
  bool IsModelEmpty();
  bool IsModelValid();
  void SetModelValid(bool v);
  void ResetModel();
  void ScriptJustRan(bool only_compute_derivatives);
  void CreateArgumentsToOptimize(bool optimize_output_requested);
  void DrawModel();
  bool PlotSweepResults(int plot_type,
      const std::string &sweep_parameter_name,
      const std::vector<double> &sweep_values,
      const std::vector<std::vector<JetComplex> > &sweep_output);
  bool ComputeSweptOutput(std::vector<JetComplex> *output);
  void PrepareForOptimize();

  // Define virtual functions from GLViewer.
  void GetBoundingBox(double bounds[6]);

  // Handling for menu and control commands.
  void ToggleShowBoundaryVertices();
  void ToggleShowBoundaryDerivatives();
  void ToggleShowBoundary();
  void ToggleGrid();

  void ViewMesh(int mesh_choicebox_selection);
  void ViewField(bool view_field);
  void Animate(bool animate);
  void SetDisplayStyle(int style);
  bool IsEzCavity() const { return config_.type == ScriptConfig::EZ; }
  bool IsExyCavity() const { return config_.type == ScriptConfig::EXY; }
  bool IsTEMode() const { return config_.type == ScriptConfig::TE; }
  bool IsTMMode() const { return config_.type == ScriptConfig::TM; }
  int NumWaveguideModes() const {
    return config_.TypeIsWaveguideMode() ? config_.max_modes : 0;
  }
  void ExportFieldMatlab(const char *filename);
  void ExportBoundaryDXF(const char *filename);
  void ExportBoundaryXY(const char *filename);
  void ToggleAntennaShow();
  void ToggleAntennaScaleMax();
  void SetWaveguideModeDisplayed(int n);

  // Connect to more external controls.
  void Connect2(wxPlot *antenna_pattern_plot);

  // Implement lua functions:
  int LuaDraw(lua_State *L);              // Draw()
  int LuaGetField(lua_State *L);          // _GetField()
  int LuaPattern(lua_State *L);           // _Pattern()
  int LuaDirectivity(lua_State *L);       // _Directivity()
  int LuaGetFieldPoynting(lua_State *L);  // _GetFieldPoynting()

 private:
  // More connections to external controls.
  wxPlot *antenna_pattern_plot_;

  // Values extracted from the config table generated by the script, excluding
  // the shape of the computational domain.
  ScriptConfig config_;

  // The objects that are currently being drawn, and drawing state.
  Shape cd_;            // Current computational domain boundary
  bool valid_;          // true if config_ and cd_ are valid, else script error
  vector<Shape> debug_shapes_;    // Shapes emitted from script as s:Draw()
  Solver *solver_;      // Solution that is computed from cd_, or 0 if none
  Solver::DrawMode solver_draw_mode_static_;      // DrawMode when not animated
  Solver::DrawMode solver_draw_mode_animating_;   // DrawMode when animating
  bool show_boundary_lines_and_ports_;
  bool show_boundary_vertices_, show_boundary_derivatives_;
  bool show_grid_;
  Mesh::MeshDrawType mesh_draw_type_;
  bool show_field_;
  bool antenna_show_, antenna_scale_max_;
  int waveguide_mode_displayed_;

  // Animation state.
  wxTimer animation_timer_;     // Triggers when it's time to display new frame
  int animation_phase_;         // -1 if static, 0..N if animating

  // Create solver_ from cd_ and config_ (unless it already exists). This sets
  // solver_==0 on failure. Return the new value of solver_.
  Solver *CreateSolver();

  // Draw the grid.
  void DrawGrid();

  // Set the config_ values from the lua_ config table, which is at the top of
  // the stack. Emit lua errors for bad values.
  void SetConfigFromTable();

  // Update the animation. This is driven from a timer event.
  void OnAnimationTimeout(wxTimerEvent& event);

  // Compute the directivity of the antenna pattern (max power / average
  // power). Return 0 if this can not be computed for some reason.
  JetNum ComputeAntennaDirectivity();

  // Compute and plot the antenna pattern.
  void PlotAntennaPattern();

  // Will we call CreateSolver() in Draw()? (assuming that we are valid_).
  bool WillCreateSolverInDraw() const {
    return mesh_draw_type_ != Mesh::MESH_HIDE || show_field_;
  }

  DECLARE_EVENT_TABLE()
};

#endif
