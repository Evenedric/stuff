
#ifndef __CAVITY_H__
#define __CAVITY_H__

#include "../toolkit/lua_model_viewer_qt.h"
#include "shape.h"
#include "solver.h"

class QDial;

class Cavity : public LuaModelViewer {
 public:
  Cavity(QWidget *parent);
  ~Cavity();

  // Define abstract functions from LuaModelViewer.
  bool IsModelEmpty();
  void ResetModel();
  void ScriptJustRan(bool only_compute_derivatives);
  void CreateArgumentsToOptimize(bool real_invocation);
  void DrawModel();
  bool PlotSweepResults(int plot_type,
      const std::string &sweep_parameter_name,
      const std::vector<double> &sweep_values,
      const std::vector<std::vector<JetComplex> > &sweep_output);
  bool ComputeSweptOutput(std::vector<JetComplex> *output);
  void PrepareForOptimize();

  // Define virtual functions from GLViewer.
  void GetBoundingBox(double bounds[6]);

  // Handling for menu and control commands.
  void ToggleShowBoundaryVertices();
  void ToggleShowBoundaryDerivatives();
  void ToggleShowBoundary();
  void ToggleGrid();
  void ToggleWidebandPulse();
  void ToggleShowSParams();
  bool GetWidebandPulse() const { return show_wideband_pulse_; }
  void SetFrequencyIndex(int n);
  int GetNumFrequencies() const;
  void TimeDialChanged(int value);
  void TimeDialToZero();

  void ViewMesh(int mesh_choicebox_selection);
  void ViewField(bool view_field);
  void Animate(bool animate);
  void SetDisplayStyle(int style);
  bool IsEzCavity() const { return config_.type == ScriptConfig::EZ; }
  bool IsExyCavity() const { return config_.type == ScriptConfig::EXY; }
  bool IsTEMode() const { return config_.type == ScriptConfig::TE; }
  bool IsTMMode() const { return config_.type == ScriptConfig::TM; }
  int NumWaveguideModes() const {
    return config_.TypeIsWaveguideMode() ? config_.max_modes : 0;
  }
  void ExportFieldMatlab(const char *filename);
  void ExportBoundaryDXF(const char *filename);
  void ExportBoundaryXY(const char *filename);
  void ToggleAntennaShow();
  void ToggleAntennaScaleMax();
  void SetWaveguideModeDisplayed(int n);

  // Connect to more external controls.
  void Connect2(qtPlot *antenna_pattern_plot, qtPlot *sparams_plot,
                QDial *time_dial);

  // Implement lua functions:
  int LuaDraw(lua_State *L);              // Draw()
  int LuaGetField(lua_State *L);          // _GetField()
  int LuaPattern(lua_State *L);           // _Pattern()
  int LuaDirectivity(lua_State *L);       // _Directivity()
  int LuaGetFieldPoynting(lua_State *L);  // _GetFieldPoynting()
  int LuaSelect(lua_State *);             // _Select()
  int LuaSolveAll(lua_State *);           // _SolveAll()
  int LuaPorts(lua_State *);              // _Ports()

  // Other plots.
  void PlotSParams(bool force_update = false);
  void SelectSParamPlot(int sparams_plot_type);

 private:
  // More connections to external controls.
  qtPlot *antenna_pattern_plot_, *sparam_plot_;
  QDial *time_dial_;

  // Values extracted from the config table generated by the script, excluding
  // the shape of the computational domain.
  ScriptConfig config_;

  // The objects that are currently being drawn, and drawing state.
  Shape cd_;            // Current computational domain boundary
  vector<Shape> debug_shapes_;    // Shapes emitted from script as s:Draw()
  Solvers solver_;                // One solver per frequency, for cd_
  Solver::DrawMode solver_draw_mode_static_;      // DrawMode when not animated
  Solver::DrawMode solver_draw_mode_animating_;   // DrawMode when animating
  bool show_boundary_lines_and_ports_;
  bool show_boundary_vertices_, show_boundary_derivatives_;
  bool show_grid_;
  Mesh::MeshDrawType mesh_draw_type_;
  bool show_field_, show_wideband_pulse_;
  bool antenna_show_, antenna_scale_max_;
  int waveguide_mode_displayed_;
  bool animating_;
  int extended_time_dial_;   // Time dial + N*32 for continuity
  int displayed_soln_;       // Solution frequency index to display
  int optimizer_soln_;       // Solution frequency index selected in optimizer
  int sparams_plot_type_;
  bool show_sparams_;
  vector<vector<JetComplex>> sparam_results_;   // Cached results

  // Create solver_ from cd_ and config_ (unless it already exists). This
  // clears solver_ on failure. Return true on success, false if solving
  // failed.
  bool CreateSolver();

  // Create the (port_power, port_phase) information for config.optimize, for
  // the given solution index.
  void CreatePortPowerAndPhase(int solution_index);

  // Draw the grid.
  void DrawGrid();

  // Set the config_ values from the lua_ config table, which is at the top of
  // the stack. Emit lua errors for bad values.
  void SetConfigFromTable();

  // Update the animation. This is driven from a timer event.
  void OnAnimationTimeout();

  // Compute the directivity of the antenna pattern (max power / average
  // power). Return 0 if this can not be computed for some reason.
  JetNum ComputeAntennaDirectivity(int solution_index);

  // Compute and plot the antenna pattern.
  void PlotAntennaPattern();

  // Will we call CreateSolver() in Draw()? (assuming that we are valid_).
  bool WillCreateSolverInDraw() const {
    return mesh_draw_type_ != Mesh::MESH_HIDE || show_field_;
  }
};

#endif
