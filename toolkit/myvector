
// Redefine the standard std::vector to perform range checks if _GLIBCXX_DEBUG
// is defined. In fact this is the standard behavior when the GNU C++ libraries
// are used, but it doesn't happen on windows or OS X. You should include this
// header instead of <vector>, then used vector<> as you normally would.

#ifndef __TOOLKIT_MYVECTOR_H__
#define __TOOLKIT_MYVECTOR_H__

#include <vector>

namespace std {

template <class T, class A = std::allocator<T> >
struct myvector : public vector<T,A> {
  typedef typename vector<T,A>::size_type _size;
  typedef typename vector<T,A>::reference _ref;
  typedef typename vector<T,A>::const_reference _const_ref;
  myvector() : vector<T,A>() {}
  myvector(_size sz) : vector<T,A>(sz) {}
  myvector(_size sz, const T& value) : vector<T,A>(sz, value) {}
  _ref operator[](_size pos) {
    #ifdef _GLIBCXX_DEBUG
      return vector<T,A>::at(pos);
    #else
      return vector<T,A>::operator[](pos);
    #endif
  }
  _const_ref operator[](_size pos) const {
    #ifdef _GLIBCXX_DEBUG
      return vector<T,A>::at(pos);
    #else
      return vector<T,A>::operator[](pos);
    #endif
  }
};

#define vector myvector

}  // namespace std

#endif
